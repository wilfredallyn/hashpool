<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hashpool Pool Dashboard</title>
    <link rel="icon" type="image/svg+xml" sizes="any" href="/favicon.svg">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>
    <style>
        body {
            font-family: 'Liberation Mono', monospace;
            background: #1a1a1a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            margin-bottom: 30px;
        }
        h2 {
            text-align: center;
            margin: 30px 0 20px 0;
            font-size: 1.5em;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 40px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .stat-box {
            text-align: center;
            padding: 20px;
            border: 1px solid #00ff00;
            min-width: 150px;
        }
        .stat-value {
            font-size: 2em;
            margin-top: 10px;
        }
        .services-section {
            margin-bottom: 40px;
            padding: 20px;
            border: 1px solid #00ff00;
            background: #222;
        }
        .services-section h3 {
            margin-top: 0;
            text-align: center;
            color: #00ff00;
        }
        .chart-section {
            margin-bottom: 40px;
            padding: 20px;
            border: 1px solid #00ff00;
            background: #222;
        }
        .chart-section h3 {
            margin-top: 0;
            text-align: center;
            color: #00ff00;
        }
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 0 40px;
            flex-wrap: wrap;
            gap: 10px;
        }
        .stats-display {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            width: 100%;
            justify-content: space-between;
        }
        .stat {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .stat label {
            color: #00aa00;
            font-size: 12px;
        }
        .stat .value {
            color: #00ff00;
            font-weight: bold;
        }
        .time-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        .time-btn {
            padding: 8px 15px;
            border: 1px solid #00ff00;
            background: #1a1a1a;
            color: #00ff00;
            cursor: pointer;
            font-family: 'Liberation Mono', monospace;
            transition: all 0.2s;
        }
        .time-btn:hover {
            background: #00ff00;
            color: #1a1a1a;
        }
        .time-btn.active {
            background: #00ff00;
            color: #1a1a1a;
        }
        .chart-container {
            position: relative;
            height: 400px;
            margin-bottom: 15px;
        }
        canvas {
            max-height: 100%;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #00ff00;
        }
        th {
            background: #0a0a0a;
            font-weight: bold;
        }
        tr:hover {
            background: #0a0a0a;
        }
        .address {
            font-family: monospace;
            font-size: 0.9em;
        }
        .status-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-up {
            background-color: #00ff00;
            box-shadow: 0 0 5px #00ff00;
        }
        .status-down {
            background-color: #ff4444;
            box-shadow: 0 0 5px #ff4444;
        }
        .service-table {
            margin-bottom: 20px;
        }
        .service-table th {
            background: #333;
        }
        .service-icon-header {
            width: 2.5em;
        }
        .service-icon-cell {
            width: 2.5em;
            text-align: center;
        }
        .proxies-table {
            width: 100%;
            border-collapse: collapse;
        }
        .proxies-table th,
        .proxies-table td {
            padding: 12px;
            border-bottom: 1px solid #00ff00;
        }
        .proxies-icon-header {
            width: 2.5em;
        }
        .proxies-icon-cell {
            width: 2.5em;
            text-align: center;
        }
        .template-provider-header {
            text-align: center;
        }
        /* {{NAV_ICON_CSS}} */
    </style>
</head>
<body>
    <div class="container">
        <h1 class="pickaxe-icon">Hashpool Dashboard</h1>

        <div class="services-section">
            <h3>Service Connections</h3>
            <table class="service-table">
                <thead>
                    <tr>
                        <th class="service-icon-header"></th>
                        <th>Service Name</th>
                        <th>IP</th>
                        <th>Port</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody id="services-tbody">
                </tbody>
            </table>
        </div>

        <!-- Aggregate Hashrate Chart -->
        <div class="chart-section">
            <h3>Aggregate Hashrate</h3>
            <div class="time-controls">
                <label>Time Range:</label>
                <button class="time-btn active" data-hours="1">1h</button>
                <button class="time-btn" data-hours="24">24h</button>
                <button class="time-btn" data-hours="168">7d</button>
            </div>
            <div class="chart-container">
                <canvas id="aggregate-chart"></canvas>
            </div>
            <div class="chart-header">
                <div class="stats-display">
                    <span class="stat">
                        <label>Current:</label>
                        <span id="current-hashrate" class="value">—</span>
                    </span>
                    <span class="stat">
                        <label>Average:</label>
                        <span id="avg-hashrate" class="value">—</span>
                    </span>
                    <span class="stat">
                        <label>Peak:</label>
                        <span id="peak-hashrate" class="value">—</span>
                    </span>
                    <span class="stat">
                        <label>Low:</label>
                        <span id="low-hashrate" class="value">—</span>
                    </span>
                </div>
            </div>
        </div>

        <div class="stats">
            <div class="stat-box">
                <div>Connected Proxies</div>
                <div class="stat-value" id="total-proxies">-</div>
            </div>
            <div class="stat-box">
                <div>Total Shares</div>
                <div class="stat-value" id="total-shares">-</div>
            </div>
            <div class="stat-box">
                <div>Total Quotes</div>
                <div class="stat-value" id="total-quotes">-</div>
            </div>
            <div class="stat-box">
                <div>Ehash Mined</div>
                <div class="stat-value" id="ehash-mined">-</div>
            </div>
        </div>

        <h2>Connected Proxies</h2>
        <table class="proxies-table">
            <thead>
                <tr>
                    <th class="proxies-icon-header"></th>
                    <th>ID</th>
                    <th>Address</th>
                    <th class="template-provider-header">Template Provider</th>
                    <th>Channels</th>
                    <th>Shares</th>
                    <th>Quotes</th>
                    <th>Ehash</th>
                    <th>Last Share</th>
                </tr>
            </thead>
            <tbody id="proxies-tbody">
            </tbody>
        </table>
    </div>

    <script>
        // ===== Utility Functions =====
        function parseAddress(address) {
            const parts = address.split(':');
            if (parts.length === 2) {
                return { ip: parts[0], port: parts[1] };
            }
            return { ip: address, port: '-' };
        }

        function getServiceMetadata(serviceType) {
            if (serviceType.includes('Pool')) {
                return { label: 'Pool', iconClass: 'pickaxe-icon' };
            }
            if (serviceType.includes('JobDeclarator')) {
                return { label: 'Job Declarator', iconClass: 'block-icon' };
            }
            if (serviceType.includes('Mint')) {
                return { label: 'Mint', iconClass: 'coins-icon' };
            }
            return { label: serviceType, iconClass: null };
        }

        // ===== Hashrate Chart Classes =====
        class HashrateCharts {
            constructor(config = {}) {
                this.config = {
                    responsive: true,
                    maintainAspectRatio: false,
                    borderWidth: 2,
                    pointRadius: 0,
                    pointHoverRadius: 8,
                    pointHitRadius: 20,  // Larger hit radius for easier tooltip triggering
                    tension: 0.1,
                    backgroundColor: 'rgba(0, 255, 0, 0.1)',
                    borderColor: '#00ff00',
                    fill: true,
                    ...config
                };
            }

            createAggregateChart(canvasId, data, animate = true, timeRangeHours = 1) {
                const ctx = document.getElementById(canvasId);
                if (!ctx) throw new Error(`Canvas element #${canvasId} not found`);

                // Destroy old chart first
                if (ctx.chart) {
                    ctx.chart.destroy();
                }

                // Use data as-is with natural Chart.js spacing
                const labels = data.map(p => this._formatTimeLabel(p.timestamp, timeRangeHours));
                const values = data.map(p => ({
                    x: p.timestamp,
                    y: p.hashrate_hs
                }));

                // Find date boundaries for vertical lines (only for 7d+ ranges)
                const dateBoundaryIndices = [];
                const dateBoundaryLabels = [];
                if (timeRangeHours >= 168) {
                    let lastDate = null;
                    data.forEach((point, index) => {
                        const date = new Date(point.timestamp * 1000);
                        const dateKey = `${date.getMonth()}-${date.getDate()}`;
                        if (lastDate !== null && lastDate !== dateKey) {
                            dateBoundaryIndices.push(index);
                            dateBoundaryLabels.push(date.toLocaleDateString('en-US', {
                                month: 'short',
                                day: 'numeric'
                            }));
                        }
                        lastDate = dateKey;
                    });
                }

                // Register plugin to draw date boundary lines with labels
                Chart.register({
                    id: 'dateBoundaryLines',
                    afterDatasetsDraw(chart) {
                        const boundaryIndices = chart.options.plugins.dateBoundaryLines?.boundaryIndices || [];
                        const boundaryData = chart.options.plugins.dateBoundaryLines?.boundaryData || [];
                        if (boundaryIndices.length === 0) return;

                        const ctx = chart.ctx;
                        const xScale = chart.scales.x;
                        const yScale = chart.scales.y;

                        ctx.save();
                        ctx.strokeStyle = 'rgba(0, 200, 0, 0.6)';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]); // Dashed line

                        boundaryIndices.forEach((index, i) => {
                            const x = xScale.getPixelForValue(index);

                            // Draw vertical line
                            ctx.beginPath();
                            ctx.moveTo(x, yScale.top);
                            ctx.lineTo(x, yScale.bottom);
                            ctx.stroke();

                            // Draw date label
                            if (boundaryData[i]) {
                                ctx.fillStyle = 'rgba(0, 200, 0, 0.8)';
                                ctx.font = 'bold 12px "Liberation Mono", monospace';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'top';
                                ctx.fillText(boundaryData[i], x, yScale.top + 5);
                            }
                        });

                        ctx.restore();
                    }
                });

                const chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels,
                        datasets: [{
                            label: 'Hashrate',
                            data: values,
                            borderColor: this.config.borderColor,
                            backgroundColor: this.config.backgroundColor,
                            fill: this.config.fill,
                            tension: this.config.tension,
                            pointRadius: this.config.pointRadius,
                            pointHoverRadius: this.config.pointHoverRadius,
                            pointHitRadius: this.config.pointHitRadius,
                            borderWidth: this.config.borderWidth,
                        }]
                    },
                    options: {
                        responsive: this.config.responsive,
                        maintainAspectRatio: this.config.maintainAspectRatio,
                        animation: {
                            duration: animate ? 400 : 0,
                        },
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            dateBoundaryLines: {
                                boundaryIndices: dateBoundaryIndices,
                                boundaryData: dateBoundaryLabels
                            },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                titleColor: '#00ff00',
                                titleFont: { weight: 'normal' },
                                bodyColor: '#00ff00',
                                borderColor: '#00ff00',
                                borderWidth: 1,
                                padding: 10,
                                displayColors: false,
                                callbacks: {
                                    title: (context) => {
                                        const hashrate = context[0].raw.y;
                                        return this._formatHashrate(hashrate);
                                    },
                                    label: (context) => {
                                        const timestamp = context.raw.x;
                                        const date = new Date(timestamp * 1000);
                                        const time = date.toLocaleTimeString('en-US', {
                                            hour: '2-digit',
                                            minute: '2-digit',
                                            hour12: true
                                        });
                                        return time;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                grid: {
                                    display: true,
                                    color: 'rgba(0, 255, 0, 0.1)'
                                },
                                ticks: {
                                    color: '#00ff00',
                                    font: {
                                        family: "'Liberation Mono', monospace",
                                        size: 12
                                    }
                                }
                            },
                            y: {
                                beginAtZero: false,
                                grid: {
                                    display: true,
                                    color: 'rgba(0, 255, 0, 0.1)'
                                },
                                ticks: {
                                    color: '#00ff00',
                                    font: {
                                        family: "'Liberation Mono', monospace",
                                        size: 12
                                    },
                                    callback: (value) => this._formatHashrate(value)
                                }
                            }
                        }
                    }
                });

                ctx.chart = chart;
                return chart;
            }

            _formatTime(unixSeconds) {
                const date = new Date(unixSeconds * 1000);
                return date.toLocaleTimeString('en-US', {
                    hour: '2-digit',
                    minute: '2-digit'
                });
            }

            _formatTimeLabel(unixSeconds, timeRangeHours) {
                const date = new Date(unixSeconds * 1000);
                // Always show time on x-axis labels
                return date.toLocaleTimeString('en-US', {
                    hour: '2-digit',
                    minute: '2-digit'
                });
            }

            _formatHashrate(hs) {
                const units = ['H/s', 'KH/s', 'MH/s', 'GH/s', 'TH/s', 'PH/s'];
                let value = hs;
                let unitIndex = 0;

                while (value >= 1000 && unitIndex < units.length - 1) {
                    value /= 1000;
                    unitIndex++;
                }

                return `${value.toFixed(2)} ${units[unitIndex]}`;
            }

            calculateStats(data) {
                if (!data || data.length === 0) {
                    return { min: 0, max: 0, avg: 0, current: 0 };
                }

                const values = data.map(p => p.hashrate_hs);
                return {
                    min: Math.min(...values),
                    max: Math.max(...values),
                    avg: values.reduce((a, b) => a + b, 0) / values.length,
                    current: values[values.length - 1]
                };
            }
        }

        // ===== Main Update Function =====
        const charts = new HashrateCharts();
        let timeRangeHours = 1;

        async function updateStats() {
            try {
                // Fetch services and connections from separate endpoints
                const [servicesResponse, connectionsResponse] = await Promise.all([
                    fetch('/api/services'),
                    fetch('/api/connections')
                ]);

                const servicesData = await servicesResponse.json();
                const connectionsData = await connectionsResponse.json();

                const services = servicesData.services || [];
                const proxies = connectionsData.proxies || [];

                // Update stats
                const totalShares = proxies.reduce((sum, p) => sum + p.shares_submitted, 0);
                const totalQuotes = proxies.reduce((sum, p) => sum + p.quotes_created, 0);
                const totalEhash = proxies.reduce((sum, p) => sum + p.ehash_mined, 0);

                document.getElementById('total-proxies').textContent = proxies.length;
                document.getElementById('total-shares').textContent = totalShares.toLocaleString();
                document.getElementById('total-quotes').textContent = totalQuotes.toLocaleString();
                document.getElementById('ehash-mined').textContent = totalEhash.toLocaleString() + ' ehash';

                // Update services table
                const servicesTbody = document.getElementById('services-tbody');
                servicesTbody.innerHTML = '';

                if (services.length === 0) {
                    servicesTbody.innerHTML = '<tr><td colspan="5" style="text-align: center; opacity: 0.5;">No service connections</td></tr>';
                } else {
                    services.forEach(service => {
                        const row = servicesTbody.insertRow();
                        const serviceMeta = getServiceMetadata(service.service_type);
                        const addr = parseAddress(service.address);

                        const iconCell = row.insertCell();
                        iconCell.className = 'service-icon-cell';
                        iconCell.innerHTML = serviceMeta.iconClass
                            ? `<span class="${serviceMeta.iconClass}" aria-hidden="true"></span>`
                            : '';

                        row.insertCell().textContent = serviceMeta.label;
                        row.insertCell().innerHTML = `<span class="address">${addr.ip}</span>`;
                        row.insertCell().textContent = addr.port;
                        row.insertCell().innerHTML = `<span class="status-dot status-up"></span>Up`;
                    });
                }

                // Update proxies table
                const proxiesTbody = document.getElementById('proxies-tbody');
                proxiesTbody.innerHTML = '';

                if (proxies.length === 0) {
                    proxiesTbody.innerHTML = '<tr><td colspan="9" style="text-align: center; opacity: 0.5;">No proxies connected</td></tr>';
                } else {
                    proxies.forEach(proxy => {
                        const row = proxiesTbody.insertRow();

                        // Icon column
                        const iconCell = row.insertCell();
                        iconCell.className = 'proxies-icon-cell';
                        if (proxy.work_selection === true) {
                            iconCell.innerHTML = '<span class="block-icon" aria-hidden="true"></span>';
                        } else {
                            iconCell.innerHTML = '<span class="miner-icon" aria-hidden="true"></span>';
                        }

                        row.insertCell().textContent = proxy.id;
                        row.insertCell().innerHTML = `<span class="address">${proxy.address}</span>`;

                        // Template Provider column
                        const templateCell = row.insertCell();
                        templateCell.style.textAlign = 'center';
                        templateCell.textContent = proxy.work_selection === true ? 'Yes' : 'No';

                        row.insertCell().textContent = proxy.channels.length > 0 ? proxy.channels.join(', ') : 'None';
                        row.insertCell().textContent = proxy.shares_submitted.toLocaleString();
                        row.insertCell().textContent = proxy.quotes_created.toLocaleString();
                        row.insertCell().textContent = proxy.ehash_mined.toLocaleString();
                        row.insertCell().textContent = proxy.last_share_at || 'Never';
                    });
                }

                // Update hashrate chart
                try {
                    await updateHashrateChart();
                } catch (err) {
                    console.warn('Hashrate chart not available:', err);
                }
            } catch (error) {
                console.error('Failed to fetch stats:', error);
            }
        }

        async function updateHashrateChart() {
            try {
                const now = Math.floor(Date.now() / 1000);
                const windowSeconds = timeRangeHours * 3600;
                const from = now - windowSeconds;
                const to = now;

                const url = `/api/hashrate?from=${from}&to=${to}`;
                const response = await fetch(url);

                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();

                if (data.data && data.data.length > 0) {
                    charts.createAggregateChart('aggregate-chart', data.data, false, timeRangeHours);
                    const stats = charts.calculateStats(data.data);
                    document.getElementById('current-hashrate').textContent = charts._formatHashrate(stats.current);
                    document.getElementById('avg-hashrate').textContent = charts._formatHashrate(stats.avg);
                    document.getElementById('peak-hashrate').textContent = charts._formatHashrate(stats.max);
                    document.getElementById('low-hashrate').textContent = charts._formatHashrate(stats.min);
                }
            } catch (error) {
                console.warn('Could not load hashrate data:', error);
            }
        }

        // Time range button handling
        document.querySelectorAll('.time-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const hours = parseInt(e.target.getAttribute('data-hours'));
                timeRangeHours = hours;

                // Update active button
                document.querySelectorAll('.time-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');

                // Update chart
                updateHashrateChart();
            });
        });

        // Update immediately and then every 3 seconds
        updateStats();
        setInterval(updateStats, 3000);
    </script>
</body>
</html>
